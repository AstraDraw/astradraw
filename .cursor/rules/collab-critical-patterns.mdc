---
description: "Critical collaboration patterns - NEVER break these invariants"
alwaysApply: true
---

# ⚠️ Critical Collaboration Patterns

**These patterns exist because breaking them caused COLLAB-001 (data loss bug). NEVER violate these rules.**

## 1. Room Storage is Source of Truth for Collaboration Scenes

```typescript
// ✅ CORRECT - Load from room storage for collaboration scenes
if (isCollabScene) {
  const sceneData = await collabAPI.startCollaboration({...});
  excalidrawAPI.updateScene({ elements: sceneData.elements });
}

// ❌ WRONG - Loading from backend API for collaboration scenes
if (isCollabScene) {
  const data = await loadWorkspaceScene(slug, id); // WRONG! This is stale
  excalidrawAPI.updateScene({ elements: data.elements });
}
```

**Why:** Backend `scene.data` is only updated periodically. Room storage (`/api/v2/rooms/{roomId}`) has the latest collaborative state.

## 2. Capture Elements BEFORE Async Operations

```typescript
// ✅ CORRECT - Capture synchronously, then async
const elementsToSave = excalidrawAPI.getSceneElementsIncludingDeleted();
collabAPI.stopCollaboration(false, elementsToSave);

// ❌ WRONG - Getting elements inside async function
async function stopCollaboration() {
  const elements = this.excalidrawAPI.getSceneElementsIncludingDeleted(); // May be empty!
  await this.saveCollabRoomToStorage(elements);
}
```

**Why:** Scene state may change during async operations. Capture it synchronously BEFORE any awaits.

## 3. Await Save Before Destroying Socket

```typescript
// ✅ CORRECT - Wait for save to complete
await this.saveCollabRoomToStorage(elements);
this.destroySocketClient();

// ❌ WRONG - Fire and forget save, then destroy
this.saveCollabRoomToStorage(elements); // Not awaited!
this.destroySocketClient(); // Socket destroyed before save completes
```

**Why:** `saveCollabRoomToStorage` needs `portal.socket` and `portal.roomId`. Destroying them first breaks the save.

## 4. Don't Save Empty Canvas During Initialization

```typescript
// ✅ CORRECT - Check roomDataLoaded flag
if (this.roomDataLoaded && elements.length > 0) {
  await this.saveCollabRoomToStorage(elements);
}

// ❌ WRONG - Save without checking if data was loaded
await this.saveCollabRoomToStorage(elements); // May save empty array!
```

**Why:** Canvas is empty when `startCollaboration` is called. Saving would overwrite real data in room storage.

## 5. Use Direct Workspace Reference, Not Stale Atoms

```typescript
// ✅ CORRECT - Use workspace directly from currentWorkspaceAtom
const workspace = useAtomValue(currentWorkspaceAtom);
const workspaceSlug = workspace?.slug;

// ❌ WRONG - Use separate slug atom that may be stale
const workspaceSlug = useAtomValue(currentWorkspaceSlugAtom); // May be out of sync!
```

**Why:** Separate atoms can become desynchronized. Always derive from the single source of truth.

## 6. Apply Loaded Data to Canvas Explicitly

```typescript
// ✅ CORRECT - Apply returned data to canvas
const sceneData = await collabAPI.startCollaboration({...});
if (sceneData?.elements) {
  excalidrawAPI.updateScene({
    elements: sceneData.elements,
    captureUpdate: CaptureUpdateAction.IMMEDIATELY,
  });
}

// ❌ WRONG - Assume data is applied automatically
const sceneData = await collabAPI.startCollaboration({...});
// Data returned but never applied to canvas!
```

**Why:** Returning data from a function doesn't update UI. Must call `updateScene()` explicitly.

## 7. Non-Blocking Scene Transitions

```typescript
// ✅ CORRECT - Fire and forget for better UX (elements already captured)
const elementsToSave = excalidrawAPI.getSceneElementsIncludingDeleted();
collabAPI.stopCollaboration(false, elementsToSave).catch(console.error);
// Continue loading new scene immediately

// ❌ WRONG - Block UI while saving
await collabAPI.stopCollaboration(false); // Blocks for 5+ seconds!
```

**Why:** Elements are captured synchronously. Save can happen in background while new scene loads.

## 8. Cancel Pending Operations When Switching Rooms

```typescript
// ✅ CORRECT - Cancel throttled operations before switching
if (this.portal.socket) {
  this.queueBroadcastAllElements.cancel();
  this.queueSaveToStorage.cancel(); // CANCEL, not flush!
  this.destroySocketClient();
}

// ❌ WRONG - Flush pending saves (saves to wrong room!)
if (this.portal.socket) {
  this.queueSaveToStorage.flush(); // Saves old data to new room!
  this.destroySocketClient();
}
```

**Why:** Flushing a throttled save after room context has changed saves data to the wrong destination.

## 9. Guard syncElements with Portal State

```typescript
// ✅ CORRECT - Check portal is open before syncing
syncElements = (elements: readonly OrderedExcalidrawElement[]) => {
  if (!this.portal.isOpen()) {
    return; // Don't sync during room transitions
  }
  this.broadcastElements(elements);
  this.queueSaveToStorage();
};

// ❌ WRONG - Sync without checking portal state
syncElements = (elements: readonly OrderedExcalidrawElement[]) => {
  this.broadcastElements(elements); // May broadcast to wrong room!
  this.queueSaveToStorage();
};
```

**Why:** During room transitions, the portal may be in an inconsistent state. Syncing could send data to the wrong room.

## 10. Use isLoading State During Scene Transitions

```typescript
// ✅ CORRECT - Show loading state, disable drawing
excalidrawAPI.updateScene({
  elements: [],
  appState: { isLoading: true }, // Disables all drawing tools
});
// ... load scene ...
excalidrawAPI.updateScene({
  elements: sceneData.elements,
  appState: { isLoading: false }, // Re-enable drawing
});

// ❌ WRONG - Just reset scene (allows drawing on empty canvas)
excalidrawAPI.resetScene(); // User can draw while scene loads!
```

**Why:** `isLoading: true` disables drawing tools. Without it, users can accidentally draw on empty canvas during load.

## 11. Clear Canvas for ALL Existing Room Joins

```typescript
// ✅ CORRECT - Reset for all existing room joins (including auto-collab)
if (existingRoomLinkData) {
  this.excalidrawAPI.resetScene();
}

// ❌ WRONG - Only reset for non-auto-collab
if (existingRoomLinkData && !isAutoCollab) {
  this.excalidrawAPI.resetScene(); // Auto-collab keeps old elements!
}
```

**Why:** Old elements on canvas get reconciled into new scene if not cleared first.

## Key Files for Collaboration

| File | Purpose |
|------|---------|
| `hooks/useSceneLoader.ts` | Scene loading, collab initialization |
| `collab/Collab.tsx` | Collaboration lifecycle, save/load |
| `data/httpStorage.ts` | HTTP storage backend for rooms |
| `components/Settings/settingsState.ts` | Navigation atoms |

## Quick Reference: Collaboration Scene Flow

```
1. User clicks scene in sidebar
   └── navigateToSceneAtom fires
       └── URL changes, popstate fires

2. handlePopState detects different scene
   └── loadScene called in useSceneLoader

3. loadScene for collab scene:
   a. Capture current elements SYNCHRONOUSLY
   b. Call stopCollaboration(false, elements) - non-blocking
   c. Load scene metadata from backend API
   d. Call startCollaboration({ fetchScene: true })
   e. Apply returned elements to canvas with updateScene()

4. startCollaboration:
   a. Join room via socket
   b. Fetch elements from room storage
   c. Set roomDataLoaded = true
   d. Return elements to caller

5. stopCollaboration:
   a. Check roomDataLoaded flag
   b. If true and elements.length > 0, save to room storage
   c. AWAIT save completion
   d. Destroy socket client
   e. Reset roomDataLoaded = false
```

## See Also

- `/docs/development/MVP_RELEASE_BUGS.md` - COLLAB-001 detailed postmortem
- `/docs/features/COLLABORATION.md` - Full collaboration documentation
- `@collaboration-system` - Collaboration architecture rule
