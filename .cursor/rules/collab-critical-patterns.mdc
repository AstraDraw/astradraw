---
description: "Critical collaboration patterns - NEVER break these invariants"
alwaysApply: true
---

# ⚠️ Critical Collaboration Patterns

**These patterns exist because breaking them caused COLLAB-001 (data loss bug). NEVER violate these rules.**

## 1. Room Storage is Source of Truth for Collaboration Scenes

```typescript
// ✅ CORRECT - Load from room storage for collaboration scenes
if (isCollabScene) {
  const sceneData = await collabAPI.startCollaboration({...});
  excalidrawAPI.updateScene({ elements: sceneData.elements });
}

// ❌ WRONG - Loading from backend API for collaboration scenes
if (isCollabScene) {
  const data = await loadWorkspaceScene(slug, id); // WRONG! This is stale
  excalidrawAPI.updateScene({ elements: data.elements });
}
```

**Why:** Backend `scene.data` is only updated periodically. Room storage (`/api/v2/rooms/{roomId}`) has the latest collaborative state.

## 2. Capture Elements BEFORE Async Operations

```typescript
// ✅ CORRECT - Capture synchronously, then async
const elementsToSave = excalidrawAPI.getSceneElementsIncludingDeleted();
collabAPI.stopCollaboration(false, elementsToSave);

// ❌ WRONG - Getting elements inside async function
async function stopCollaboration() {
  const elements = this.excalidrawAPI.getSceneElementsIncludingDeleted(); // May be empty!
  await this.saveCollabRoomToStorage(elements);
}
```

**Why:** Scene state may change during async operations. Capture it synchronously BEFORE any awaits.

## 3. Await Save Before Destroying Socket

```typescript
// ✅ CORRECT - Wait for save to complete
await this.saveCollabRoomToStorage(elements);
this.destroySocketClient();

// ❌ WRONG - Fire and forget save, then destroy
this.saveCollabRoomToStorage(elements); // Not awaited!
this.destroySocketClient(); // Socket destroyed before save completes
```

**Why:** `saveCollabRoomToStorage` needs `portal.socket` and `portal.roomId`. Destroying them first breaks the save.

## 4. Don't Save Empty Canvas During Initialization

```typescript
// ✅ CORRECT - Check roomDataLoaded flag
if (this.roomDataLoaded && elements.length > 0) {
  await this.saveCollabRoomToStorage(elements);
}

// ❌ WRONG - Save without checking if data was loaded
await this.saveCollabRoomToStorage(elements); // May save empty array!
```

**Why:** Canvas is empty when `startCollaboration` is called. Saving would overwrite real data in room storage.

## 5. Use Direct Workspace Reference, Not Stale Atoms

```typescript
// ✅ CORRECT - Use workspace directly from currentWorkspaceAtom
const workspace = useAtomValue(currentWorkspaceAtom);
const workspaceSlug = workspace?.slug;

// ❌ WRONG - Use separate slug atom that may be stale
const workspaceSlug = useAtomValue(currentWorkspaceSlugAtom); // May be out of sync!
```

**Why:** Separate atoms can become desynchronized. Always derive from the single source of truth.

## 6. Apply Loaded Data to Canvas Explicitly

```typescript
// ✅ CORRECT - Apply returned data to canvas
const sceneData = await collabAPI.startCollaboration({...});
if (sceneData?.elements) {
  excalidrawAPI.updateScene({
    elements: sceneData.elements,
    captureUpdate: CaptureUpdateAction.IMMEDIATELY,
  });
}

// ❌ WRONG - Assume data is applied automatically
const sceneData = await collabAPI.startCollaboration({...});
// Data returned but never applied to canvas!
```

**Why:** Returning data from a function doesn't update UI. Must call `updateScene()` explicitly.

## 7. Non-Blocking Scene Transitions

```typescript
// ✅ CORRECT - Fire and forget for better UX (elements already captured)
const elementsToSave = excalidrawAPI.getSceneElementsIncludingDeleted();
collabAPI.stopCollaboration(false, elementsToSave).catch(console.error);
// Continue loading new scene immediately

// ❌ WRONG - Block UI while saving
await collabAPI.stopCollaboration(false); // Blocks for 5+ seconds!
```

**Why:** Elements are captured synchronously. Save can happen in background while new scene loads.

## Key Files for Collaboration

| File | Purpose |
|------|---------|
| `hooks/useSceneLoader.ts` | Scene loading, collab initialization |
| `collab/Collab.tsx` | Collaboration lifecycle, save/load |
| `data/httpStorage.ts` | HTTP storage backend for rooms |
| `components/Settings/settingsState.ts` | Navigation atoms |

## Quick Reference: Collaboration Scene Flow

```
1. User clicks scene in sidebar
   └── navigateToSceneAtom fires
       └── URL changes, popstate fires

2. handlePopState detects different scene
   └── loadScene called in useSceneLoader

3. loadScene for collab scene:
   a. Capture current elements SYNCHRONOUSLY
   b. Call stopCollaboration(false, elements) - non-blocking
   c. Load scene metadata from backend API
   d. Call startCollaboration({ fetchScene: true })
   e. Apply returned elements to canvas with updateScene()

4. startCollaboration:
   a. Join room via socket
   b. Fetch elements from room storage
   c. Set roomDataLoaded = true
   d. Return elements to caller

5. stopCollaboration:
   a. Check roomDataLoaded flag
   b. If true and elements.length > 0, save to room storage
   c. AWAIT save completion
   d. Destroy socket client
   e. Reset roomDataLoaded = false
```

## See Also

- `/docs/development/MVP_RELEASE_BUGS.md` - COLLAB-001 detailed postmortem
- `/docs/features/COLLABORATION.md` - Full collaboration documentation
- `@collaboration-system` - Collaboration architecture rule
