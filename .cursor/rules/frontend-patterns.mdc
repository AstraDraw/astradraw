---
description: "Frontend development patterns for AstraDraw (React/Excalidraw)"
alwaysApply: true
---

# Frontend Development Patterns

## Project Location

Frontend code is in `frontend/` (formerly `excalidraw/`). It's a fork of the upstream Excalidraw repository.

## Key Directories

```
frontend/
├── excalidraw-app/           # AstraDraw-specific code
│   ├── auth/                 # Authentication (AuthProvider, workspaceApi)
│   ├── components/           # Custom components
│   │   ├── Workspace/        # Sidebar, SceneCard, LoginDialog, UserProfile
│   │   ├── Settings/         # ProfilePage, MembersPage, TeamsCollectionsPage
│   │   ├── EmojiPicker/      # Emoji picker for collection icons
│   │   ├── Talktrack/        # Recording feature
│   │   ├── Presentation/     # Slideshow mode
│   │   ├── Stickers/         # GIPHY integration (twemojiApi for EmojiPicker)
│   │   └── AppSidebar.tsx    # Main sidebar with tabs
│   ├── pens/                 # Custom pen presets
│   └── App.tsx               # Main app component
├── packages/excalidraw/      # Core Excalidraw library
│   ├── components/           # Core UI components
│   ├── locales/              # Translation files (en.json, ru-RU.json)
│   └── types.ts              # TypeScript types
```

## State Management

- **Jotai** for global state (atoms)
- **React useState/useEffect** for component state
- **ExcalidrawAPI** for canvas operations

```typescript
// Example: Using Jotai atoms
import { atom, useAtom } from "jotai";
const myAtom = atom<boolean>(false);
const [value, setValue] = useAtom(myAtom);

// Example: Using ExcalidrawAPI
excalidrawAPI.updateScene({ elements, appState });
excalidrawAPI.scrollToContent(element, { animate: true });
```

## App Mode & Navigation (Dashboard ↔ Canvas)

AstraDraw has two main modes controlled by Jotai atoms in `components/Settings/settingsState.ts`:

| Mode | `appModeAtom` Value | What's Displayed |
|------|---------------------|------------------|
| Dashboard | `"dashboard"` | Dashboard, Collections, Settings pages |
| Canvas | `"canvas"` | Excalidraw drawing canvas |

### URL-Based Navigation

**All navigation actions update the browser URL.** This ensures:
- Browser back/forward buttons work correctly
- Pages can be refreshed without losing context
- URLs can be shared and bookmarked

URL patterns:
- Dashboard: `/workspace/{slug}/dashboard`
- Collection: `/workspace/{slug}/collection/{id}` or `/workspace/{slug}/private`
- Scene: `/workspace/{slug}/scene/{id}`
- Settings: `/workspace/{slug}/settings`
- Members: `/workspace/{slug}/members`
- Teams: `/workspace/{slug}/teams`
- Profile: `/profile`

See `/docs/URL_ROUTING.md` for full documentation.

### Navigation Atoms

```typescript
import {
  appModeAtom,
  navigateToCanvasAtom,
  navigateToDashboardAtom,
  navigateToCollectionAtom,
  navigateToProfileAtom,
  navigateToSceneAtom,
  activeCollectionIdAtom,
  dashboardViewAtom,
  currentWorkspaceSlugAtom,
  currentSceneIdAtom,
} from "./components/Settings/settingsState";

// Reading current mode
const appMode = useAtomValue(appModeAtom);

// Navigation actions (use useSetAtom, not useAtom)
// These automatically push URLs to browser history
const navigateToCanvas = useSetAtom(navigateToCanvasAtom);
const navigateToDashboard = useSetAtom(navigateToDashboardAtom);
const navigateToCollection = useSetAtom(navigateToCollectionAtom);
```

### URL Router Utilities

For building URLs or parsing the current route:

```typescript
import {
  parseUrl,
  buildSceneUrl,
  buildDashboardUrl,
  buildCollectionUrl,
  navigateTo,
  type RouteType,
} from "../../router";

// Parse current URL
const route = parseUrl(); // Returns RouteType

// Build URLs
const sceneUrl = buildSceneUrl(workspaceSlug, sceneId);
const dashboardUrl = buildDashboardUrl(workspaceSlug);

// Navigate programmatically (pushes to history)
navigateTo(buildSceneUrl(workspaceSlug, sceneId));
```

### Switching from Dashboard to Canvas

**CRITICAL:** When creating a new scene or opening a scene from the dashboard, you MUST call `navigateToCanvas()` to switch to canvas mode. Otherwise, the app stays in dashboard mode and the canvas is not visible.

```typescript
// Example: Creating a new scene from a collection's context menu
const handleNewScene = useCallback(async (collectionId?: string) => {
  // 1. Create the scene in backend (with the collection ID!)
  const scene = await createScene({ title, collectionId });
  
  // 2. Reset and prepare the canvas
  excalidrawAPI.resetScene();
  
  // 3. Set current scene state
  setCurrentSceneId(scene.id);
  setCurrentSceneTitle(title);
  
  // 4. IMPORTANT: Set the active collection so sidebar shows scenes from this collection
  if (collectionId) {
    setActiveCollectionId(collectionId);
  }
  
  // 5. Keep sidebar open to show the new scene in the collection's scene list
  setWorkspaceSidebarOpen(true);
  
  // 6. Switch to canvas mode - sidebar auto-switches to "board" mode
  navigateToCanvas();
  
  // 7. Save initial scene data
  await updateSceneData(scene.id, blob);
}, [excalidrawAPI, navigateToCanvas, setActiveCollectionId]);
```

**Key behavior:** When creating a scene from a collection:
- The scene is created in that specific collection
- The sidebar stays open showing the collection's scenes (in "board" mode)
- The new scene appears in the scene list and is selected
- User can immediately start drawing on the canvas

### Switching from Canvas to Dashboard

```typescript
// Example: Going back to dashboard
const handleBackToDashboard = useCallback(() => {
  navigateToDashboard();
}, [navigateToDashboard]);

// Example: Opening a specific collection
const handleCollectionClick = useCallback((collectionId: string) => {
  navigateToCollection(collectionId);
}, [navigateToCollection]);
```

### Opening an Existing Scene

> ⚠️ **Work in Progress (December 2025)**: This pattern is functional but needs further testing across all navigation scenarios.

**IMPORTANT:** Scene loading is centralized in `App.tsx`. Child components should NOT load scene data directly. Instead, they use `navigateToSceneAtom` which triggers URL-based navigation.

```typescript
// In DashboardView, CollectionView, or WorkspaceSidebar:
import { useSetAtom, useAtomValue } from "../../app-jotai";
import { navigateToSceneAtom, currentWorkspaceSlugAtom } from "../Settings/settingsState";

const navigateToScene = useSetAtom(navigateToSceneAtom);
const currentWorkspaceSlug = useAtomValue(currentWorkspaceSlugAtom);

const handleOpenScene = useCallback(
  (scene: WorkspaceScene) => {
    if (currentWorkspaceSlug) {
      navigateToScene({
        workspaceSlug: currentWorkspaceSlug,
        sceneId: scene.id,
        title: scene.title,
      });
    }
  },
  [navigateToScene, currentWorkspaceSlug],
);
```

**How it works:**
1. `navigateToSceneAtom` sets Jotai atoms and calls `navigateTo()` with the scene URL
2. `navigateTo()` pushes URL and dispatches a `popstate` event
3. `handlePopState` in `App.tsx` sets `appMode("canvas")` and calls `loadSceneFromUrlRef.current()`
4. `loadSceneFromUrl()` fetches scene data, updates canvas, and handles collaboration

**Key principle - One-Way URL Flow:**
- **User action** → Navigation atom → Push URL → Dispatch popstate
- **Popstate handler** → Parse URL → Set state directly (**NO URL push**)

**Why this pattern?**
- Prevents infinite loops (popstate handlers must not push URLs)
- Single source of truth for scene loading logic
- Browser back/forward buttons work correctly
- No duplicate API calls

### Dashboard Views

Within dashboard mode, different views are controlled by `dashboardViewAtom`:

| View | Value | Component |
|------|-------|-----------|
| Home | `"home"` | `DashboardView` |
| Collection | `"collection"` | `CollectionView` |
| Profile | `"profile"` | `ProfilePage` |
| Workspace Settings | `"workspace"` | `WorkspaceSettingsPage` |
| Team Members | `"members"` | `MembersPage` |
| Teams & Collections | `"teams-collections"` | `TeamsCollectionsPage` |

### Key Files

- `frontend/excalidraw-app/router.ts` - URL routing utilities (parseUrl, buildUrl, navigateTo)
- `frontend/excalidraw-app/components/Settings/settingsState.ts` - Navigation atoms with URL support
- `frontend/excalidraw-app/App.tsx` - Main app with URL sync and mode switching
- `frontend/excalidraw-app/components/Workspace/WorkspaceSidebar.tsx` - Sidebar navigation
- `frontend/excalidraw-app/components/Workspace/WorkspaceMainContent.tsx` - Dashboard content router

### Scene Loading Architecture (Excalidraw Plus Pattern)

**Dashboard-First Architecture:**
- Authenticated users start in the **dashboard**, not the canvas
- Canvas only renders when a **specific scene** is being loaded
- Each scene has a **unique URL** that always loads that scene's data
- Works like Room Service: URL = specific data

**Critical: initialStatePromiseRef Management**

The `initialStatePromiseRef` holds a promise that Excalidraw waits for on mount. It must be **reset for each scene**:

```typescript
const loadSceneFromUrl = async (workspaceSlug, sceneId, options) => {
  const { isInitialLoad = false } = options;
  
  // CRITICAL: Reset promise for new scene (not initial load)
  if (!isInitialLoad) {
    initialStatePromiseRef.current.promise =
      resolvablePromise<ExcalidrawInitialDataState | null>();
  }
  
  // Fetch scene data...
  const loaded = await loadWorkspaceScene(workspaceSlug, sceneId);
  
  // Resolve promise with scene data
  initialStatePromiseRef.current.promise.resolve({
    elements: sceneData.elements,
    appState: sceneData.appState,
    files: sceneData.files,
  });
};
```

**Race Condition Handling:**

When user rapidly switches scenes, only apply the latest request:

```typescript
let currentLoadingSceneId: string | null = null;

const loadSceneFromUrl = async (workspaceSlug, sceneId) => {
  currentLoadingSceneId = sceneId;  // Track current request
  
  const loaded = await loadWorkspaceScene(workspaceSlug, sceneId);
  
  // Ignore stale results
  if (currentLoadingSceneId !== sceneId) {
    return;  // Another scene was requested, ignore this one
  }
  
  // Apply scene data...
};
```

**Loading States:**

```typescript
const [isLoadingScene, setIsLoadingScene] = useState(false);
const [sceneDataLoaded, setSceneDataLoaded] = useState(false);

// Show spinner while loading
if (appMode === "canvas" && isLoadingScene) {
  return <LoadingSpinner />;
}
```

**See:** `/docs/SCENE_NAVIGATION.md` for complete documentation.

## Localization

**Always add translation keys** for new UI text:

1. Add to `packages/excalidraw/locales/en.json`
2. Add to `packages/excalidraw/locales/ru-RU.json`
3. Use `t("key.path")` in components

```typescript
import { t } from "@excalidraw/excalidraw/i18n";
<span>{t("workspace.myProfile")}</span>
```

## Input Fields in Dialogs

**Critical:** Stop keyboard event propagation in input fields to prevent canvas shortcuts:

```typescript
<input
  onKeyDown={(e) => e.stopPropagation()}
  onKeyUp={(e) => e.stopPropagation()}
  ...
/>
```

## Styling

- Use SCSS modules (`.scss` files alongside components)
- Support dark mode via CSS variables
- Use `var(--island-bg-color)`, `var(--text-primary-color)`, etc.

```scss
.my-component {
  background: var(--island-bg-color, #fff);
  color: var(--text-primary-color, #1b1b1f);
}

.excalidraw.theme--dark {
  .my-component {
    background: var(--island-bg-color, #232329);
  }
}
```

### Creating New Components Outside `.excalidraw`

**CRITICAL:** Components in `excalidraw-app/components/` (Workspace, Settings, EmojiPicker, etc.) render outside the main `.excalidraw` container and don't inherit global CSS variables.

**Always add this at the root of new component SCSS files:**

```scss
.my-new-component {
  // Define --ui-font locally since component is outside .excalidraw container
  --ui-font: Assistant, system-ui, BlinkMacSystemFont, -apple-system, Segoe UI,
    Roboto, Helvetica, Arial, sans-serif;
  font-family: var(--ui-font);

  // ... rest of styles
}
```

**Why?** Without this, text falls back to Times New Roman or other serif fonts.

## Reusable UI Patterns

### Emoji Picker

Use the `EmojiPicker` component for icon selection:

```typescript
import { EmojiPicker } from "../EmojiPicker";

<EmojiPicker
  value={selectedEmoji}      // Current emoji or empty string
  onSelect={setSelectedEmoji} // Callback when emoji selected
/>
```

Features: category tabs, search, frequently used, random, remove button.

### Click-Outside Handler for Menus

For dropdowns/context menus that should close on outside click:

```typescript
const menuRef = useRef<HTMLDivElement>(null);
const [menuOpen, setMenuOpen] = useState<string | null>(null);

useEffect(() => {
  const handleClickOutside = (event: MouseEvent) => {
    if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
      setMenuOpen(null);
    }
  };

  if (menuOpen) {
    document.addEventListener("mousedown", handleClickOutside);
  }
  return () => document.removeEventListener("mousedown", handleClickOutside);
}, [menuOpen]);
```

## API Calls

Use functions from `auth/workspaceApi.ts`:

```typescript
import { listScenes, createScene, getUserProfile } from "../../auth/workspaceApi";

// All API calls use credentials: "include" for JWT cookies
const scenes = await listScenes();
```

## Environment Variables in Docker

**CRITICAL:** Vite environment variables (`import.meta.env.VITE_*`) are baked in at build time. In Docker, we need runtime configuration.

### How It Works

1. **Build time:** Dockerfile sets placeholder values:
   ```dockerfile
   ENV VITE_APP_WS_SERVER_URL=__VITE_APP_WS_SERVER_URL__ \
       VITE_DEBUG_NAVIGATION=__VITE_DEBUG_NAVIGATION__
   ```

2. **Runtime:** `docker-entrypoint.sh` creates `/usr/share/nginx/html/env-config.js`:
   ```javascript
   window.__ENV__ = {
     VITE_APP_WS_SERVER_URL: "https://actual-domain.com",
     VITE_DEBUG_NAVIGATION: "true"
   };
   ```

3. **Code access:** Check `window.__ENV__` first, fall back to `import.meta.env`:
   ```typescript
   function getEnvVar(name: string, defaultValue: string = ""): string {
     // Runtime env (Docker) takes precedence
     if (typeof window !== "undefined" && window.__ENV__?.[name]) {
       return window.__ENV__[name];
     }
     // Fall back to build-time env (Vite dev server)
     return import.meta.env[name] ?? defaultValue;
   }
   ```

### Adding a New Environment Variable

When adding a new `VITE_*` environment variable:

1. **Dockerfile** - Add to build-time ENV block:
   ```dockerfile
   ENV VITE_MY_NEW_VAR=__VITE_MY_NEW_VAR__
   ```

2. **docker-entrypoint.sh** - Add extraction and output:
   ```bash
   # In the get_secret section:
   MY_NEW_VAR=$(get_secret "VITE_MY_NEW_VAR" "default_value")
   
   # In the cat > env-config.js section:
   VITE_MY_NEW_VAR: "${MY_NEW_VAR}",
   ```

3. **docker-compose.yml** - Add to app service environment:
   ```yaml
   app:
     environment:
       - VITE_MY_NEW_VAR=${MY_NEW_VAR:-default}
   ```

4. **TypeScript** - Extend Window interface if needed:
   ```typescript
   declare global {
     interface Window {
       __ENV__?: {
         VITE_MY_NEW_VAR?: string;
         // ... other vars
       };
     }
   }
   ```

### Example: Checking a Feature Flag

```typescript
// Helper function pattern
function isFeatureEnabled(envVar: string): boolean {
  if (typeof window !== "undefined" && window.__ENV__?.[envVar]) {
    return window.__ENV__[envVar] === "true";
  }
  return import.meta.env[envVar] === "true";
}

// Usage
const DEBUG_ENABLED = isFeatureEnabled("VITE_DEBUG_NAVIGATION");
```

### Files Involved

| File | Purpose |
|------|---------|
| `frontend/Dockerfile` | Build-time placeholder ENV vars |
| `frontend/docker-entrypoint.sh` | Runtime env injection via `window.__ENV__` |
| `frontend/excalidraw-app/env.ts` | Helper to read env vars (if exists) |
| `deploy/docker-compose.yml` | Pass env vars to containers |

## Build & Check Commands

```bash
cd frontend
yarn install              # Install dependencies
yarn start                # Development server
yarn build:app:docker     # Production build for Docker

# Required checks before release:
yarn test:typecheck       # TypeScript type checking
yarn test:other           # Prettier formatting check
yarn test:code            # ESLint code quality
yarn test:all             # Run ALL checks + tests

# Auto-fix commands:
yarn fix:other            # Auto-fix Prettier
yarn fix:code             # Auto-fix ESLint
yarn fix                  # Fix both
```

