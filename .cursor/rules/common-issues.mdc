---
description: "Common issues and solutions encountered in AstraDraw development"
alwaysApply: true
---

# Common Issues and Solutions

## Frontend Issues

### 1. Translation Key Errors

**Error:** `Argument of type '"some.key"' is not assignable to parameter of type 'NestedKeyOf<{...}>'`

**Solution:** Add the missing key to locale files:
- `frontend/packages/excalidraw/locales/en.json`
- `frontend/packages/excalidraw/locales/ru-RU.json`

### 2. Input Fields Affecting Canvas

**Problem:** Typing in input fields (especially `@`, shortcuts) triggers canvas actions.

**Solution:** Stop event propagation:
```typescript
<input
  onKeyDown={(e) => e.stopPropagation()}
  onKeyUp={(e) => e.stopPropagation()}
/>
```

### 3. Sidebar Overlay vs Push

**Problem:** Sidebar overlays canvas instead of pushing content.

**Solution:** Use flexbox layout:
```scss
.excalidraw-app {
  display: flex;
  .excalidraw-wrapper {
    flex-grow: 1;
  }
}
```

### 4. Auto-save Not Working

**Solution:** Implement debounced save with change detection:
```typescript
const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
const lastSavedDataRef = useRef<string>("");

// Compare serialized data to detect changes
const currentData = JSON.stringify(elements);
if (currentData !== lastSavedDataRef.current) {
  setHasUnsavedChanges(true);
}
```

### 5. Fonts Look Like Times New Roman in Dashboard/Workspace Components

**Problem:** Text in dashboard, collection views, or scene cards appears in a serif font (Times New Roman) instead of the UI font (Assistant).

**Cause:** Components outside the `.excalidraw` container don't inherit the `--ui-font` CSS variable. The variable is defined in `.excalidraw` class but workspace components (DashboardView, CollectionView, SceneCardGrid, etc.) are rendered outside this container.

**Solution:** Define `--ui-font` locally in each SCSS file for components outside `.excalidraw`:
```scss
.dashboard-view {
  // Define --ui-font locally since component is outside .excalidraw container
  --ui-font: Assistant, system-ui, BlinkMacSystemFont, -apple-system, Segoe UI,
    Roboto, Helvetica, Arial, sans-serif;
  font-family: var(--ui-font);

  // ... rest of styles
}
```

**Files that need this pattern** (if they're outside `.excalidraw`):
- `DashboardView.scss` âœ…
- `CollectionView.scss` âœ…
- `SceneCardGrid.scss` âœ…
- `WorkspaceSidebar.scss` âœ…
- `SceneCard.scss` âœ…
- `LoginDialog.scss` âœ…
- `UserProfileDialog.scss` âœ…
- `ProfilePage.scss` âœ…
- `WorkspaceSettingsPage.scss` âœ…
- `MembersPage.scss` âœ…
- `TeamsCollectionsPage.scss` âœ…
- `EmojiPicker.scss` âœ…
- **Any new workspace/settings/dashboard components**

**IMPORTANT:** When creating a new component in `excalidraw-app/components/` that renders outside the main `.excalidraw` container (e.g., Settings pages, Workspace components, dialogs), ALWAYS add the `--ui-font` definition at the root of its SCSS file.

**Also avoid:** Using `font-family: "Virgil", cursive, var(--ui-font)` which falls back to cursive/serif fonts. Use `var(--ui-font)` directly or inherit from parent.

### 6. Dropdown/Context Menu Not Closing on Outside Click

**Problem:** Context menus or dropdowns don't close when clicking outside them.

**Solution:** Use `useRef` and `useEffect` with a `mousedown` event listener:
```typescript
const menuRef = useRef<HTMLDivElement>(null);
const [menuOpen, setMenuOpen] = useState<string | null>(null);

useEffect(() => {
  const handleClickOutside = (event: MouseEvent) => {
    if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
      setMenuOpen(null);
    }
  };

  if (menuOpen) {
    document.addEventListener("mousedown", handleClickOutside);
  }

  return () => {
    document.removeEventListener("mousedown", handleClickOutside);
  };
}, [menuOpen]);

// In JSX:
<div ref={menuOpen === itemId ? menuRef : null}>
  {/* menu content */}
</div>
```

### 7. Hardcoded Strings Not Translated

**Problem:** Some UI text appears in English even when Russian locale is selected.

**Cause:** Hardcoded strings in components instead of using `t()` function.

**Solution:** 
1. Search for hardcoded strings in the component
2. Add translation keys to both `en.json` and `ru-RU.json`
3. Replace hardcoded strings with `t("key.path")`

**Russian localization tips:**
- Don't translate word-for-word; adapt to natural Russian phrasing
- "by You" â†’ "ÐÐ²Ñ‚Ð¾Ñ€: Ð’Ñ‹" (not "Ð¾Ñ‚ Ð’Ð°Ñ")
- "Just now" â†’ "Ð¢Ð¾Ð»ÑŒÐºÐ¾ Ñ‡Ñ‚Ð¾"
- Use `{{count}}` for pluralization: "{{count}} Ð¼Ð¸Ð½. Ð½Ð°Ð·Ð°Ð´"

### 8. Data Not Updating Across Components (Cross-Component State Sync)

**Problem:** Data created/updated in one component (e.g., sidebar) doesn't appear in another component (e.g., TeamsCollectionsPage) without a page refresh.

**Cause:** Multiple components have their own local state and fetch data independently. When one component modifies data, others don't know about it.

**Solution:** Use Jotai refresh trigger atoms for cross-component communication:

```typescript
// In settingsState.ts - already defined
export const collectionsRefreshAtom = atom(0);
export const triggerCollectionsRefreshAtom = atom(null, (get, set) => {
  set(collectionsRefreshAtom, get(collectionsRefreshAtom) + 1);
});

// In component that modifies data (e.g., sidebar)
const triggerCollectionsRefresh = useSetAtom(triggerCollectionsRefreshAtom);

const handleCreateCollection = async () => {
  await createCollection(...);
  setLocalCollections(prev => [...prev, newCollection]);
  triggerCollectionsRefresh(); // Notify other components
};

// In component that displays data (e.g., TeamsCollectionsPage)
const collectionsRefresh = useAtomValue(collectionsRefreshAtom);

useEffect(() => {
  loadData();
}, [loadData, collectionsRefresh]); // Re-fetch when refresh is triggered
```

**Available refresh atoms:**
- `collectionsRefreshAtom` / `triggerCollectionsRefreshAtom` - For collection changes
- `scenesRefreshAtom` / `triggerScenesRefreshAtom` - For scene changes

**When to use:**
- After creating, updating, or deleting collections from sidebar
- After creating, renaming, duplicating, or deleting scenes
- When data is modified in one component but displayed in another

### 9. ðŸš¨ CRITICAL: Infinite Loop in URL Navigation (Stack Overflow)

**Problem:** App crashes with "Maximum call stack size exceeded" when navigating or on page load.

**Cause:** Navigation atoms push URLs via `navigateTo()`, which dispatches `popstate`, which triggers `handlePopState`, which calls a navigation atom again â†’ infinite recursion.

**Example of the bug:**
```typescript
// In handlePopState (called on popstate event):
const handlePopState = () => {
  const route = parseUrl();
  if (route.type === "dashboard") {
    navigateToDashboard();  // âŒ This pushes URL â†’ triggers popstate â†’ infinite loop!
  }
};

// navigateToDashboard internally does:
navigateTo(buildDashboardUrl(slug));  // Dispatches popstate event!
```

**Solution - One-Way URL Flow:**
```typescript
// In handlePopState - set state DIRECTLY, don't push URLs:
const handlePopState = () => {
  const route = parseUrl();
  if (route.type === "dashboard") {
    setAppMode("dashboard");    // âœ… Direct state set
    setDashboardView("home");   // âœ… No URL push
  }
};
```

**Rule:** `handlePopState` and `handleUrlRoute` should NEVER call navigation atoms that push URLs. They should only set state atoms directly.

**When to use navigation atoms (that push URLs):**
- User clicks a button/link
- Programmatic navigation from user action

**When to set state directly (no URL push):**
- `handlePopState` (browser back/forward)
- `handleUrlRoute` (processing URL changes)
- Initial URL parsing on page load

### 10. ðŸš¨ CRITICAL: Infinite Loop in useEffect (API Polling Loop)

**Problem:** The app makes hundreds of API requests per second, causing performance issues and server overload.

**Cause:** A `useEffect` hook has a state variable in its dependency array, but also calls a setter that changes that state (directly or indirectly through callbacks/parent components).

**Common patterns that cause infinite loops:**

#### Pattern 1: Direct state dependency loop
```typescript
// âŒ BAD: activeCollectionId in deps, but setActiveCollectionId called inside
useEffect(() => {
  loadData().then((data) => {
    if (!activeCollectionId) {
      setActiveCollectionId(data.defaultId); // Changes activeCollectionId â†’ re-runs effect
    }
  });
}, [activeCollectionId, setActiveCollectionId]); // â† activeCollectionId causes loop
```

```typescript
// âœ… GOOD: Use a ref to track if default was already set
const hasSetDefaultRef = useRef(false);

useEffect(() => {
  loadData().then((data) => {
    if (!hasSetDefaultRef.current) {
      hasSetDefaultRef.current = true;
      setActiveCollectionId(data.defaultId);
    }
  });
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, [setActiveCollectionId]); // Removed activeCollectionId from deps
```

#### Pattern 2: Callback chain loop (Parent â†” Child)
```typescript
// âŒ BAD: Child notifies parent on every collections change
// WorkspaceSidebar.tsx
useEffect(() => {
  if (currentWorkspace) {
    onWorkspaceChange(currentWorkspace, privateCollection?.id);
  }
}, [currentWorkspace, collections, onWorkspaceChange]); // â† collections causes loop

// App.tsx - Parent reloads collections when notified
onWorkspaceChange={(workspace) => {
  listCollections(workspace.id).then(setCollections); // Updates collections â†’ triggers child effect
}}
```

```typescript
// âœ… GOOD: Only notify parent once per workspace change
const lastNotifiedWorkspaceRef = useRef<string | null>(null);

useEffect(() => {
  if (currentWorkspace && lastNotifiedWorkspaceRef.current !== currentWorkspace.id) {
    lastNotifiedWorkspaceRef.current = currentWorkspace.id;
    onWorkspaceChange(currentWorkspace, privateCollection?.id);
  }
}, [currentWorkspace, collections, onWorkspaceChange]);
```

#### Pattern 3: Redundant data fetching
```typescript
// âŒ BAD: Both parent and child fetch the same data
// Child already loads collections, but parent also reloads them
onWorkspaceChange={(workspace) => {
  listCollections(workspace.id).then(setCollections); // Redundant!
}}
```

```typescript
// âœ… GOOD: Let one component own the data loading
onWorkspaceChange={(workspace, privateColId) => {
  setCurrentWorkspace(workspace);
  setPrivateCollectionId(privateColId);
  // Don't reload collections - child already loaded them
}}
```

**Debugging infinite loops:**
1. Open browser DevTools â†’ Network tab
2. Look for repeated requests to the same endpoint
3. Check the call stack to find which component/effect is triggering
4. Search for `useEffect` hooks that both depend on and modify the same state

**Prevention checklist for new useEffect hooks:**
- [ ] Does this effect call any state setters?
- [ ] Are any of those state variables also in the dependency array?
- [ ] Does this effect call any callbacks that might update state in parent/sibling components?
- [ ] Could those state updates cause this effect to re-run?
- [ ] If yes to any: Use a ref to prevent duplicate executions

**IMPORTANT:** When you see an effect that sets state, ALWAYS check if that state (or derived state) is in the dependency array. If it is, you likely have an infinite loop.

### 11. Scene Data Loss When Navigating Between Dashboard and Canvas

> âœ… **SOLVED** - See `/docs/CRITICAL_CSS_HIDE_SHOW_FIX.md` for the complete solution.

**Problem:** Scene data was lost or reset when navigating between dashboard and canvas views.

**Root Cause:** The original code used conditional rendering (`if (appMode === "dashboard") return <Dashboard />`) which caused Excalidraw to unmount/remount when switching modes, losing all state.

**Solution: CSS Hide/Show Pattern**

Instead of conditional rendering, both Dashboard and Canvas are **always mounted** and CSS `display: none` toggles visibility:

```typescript
// âœ… CORRECT - CSS Hide/Show (current implementation)
return (
  <>
    <div style={{ display: appMode === "dashboard" ? "block" : "none" }}>
      <WorkspaceMainContent />
    </div>
    <div 
      style={{ display: appMode === "canvas" ? "block" : "none" }}
      inert={appMode !== "canvas" ? true : undefined}
    >
      <Excalidraw />
    </div>
  </>
);
```

**Key safeguards:**
- `display: none` - Hides visually
- `inert` attribute - Prevents all user interaction when hidden
- `handleKeyboardGlobally={appMode === "canvas"}` - Disables keyboard when hidden
- `body.excalidraw-disabled` class - Additional CSS hook

**See:** `/docs/CRITICAL_CSS_HIDE_SHOW_FIX.md` for complete documentation.

### 12. Browser Back/Forward Buttons Not Working

**Problem:** Clicking browser back/forward doesn't navigate correctly in the app.

**Cause:** Navigation only changes React state, not browser history.

**Solution:** All navigation atoms now push URLs and the app listens for `popstate` events:

```typescript
// In App.tsx
useEffect(() => {
  const handlePopState = async (event: PopStateEvent) => {
    const route = parseUrl();
    // Update state based on route type
  };
  
  window.addEventListener("popstate", handlePopState);
  return () => window.removeEventListener("popstate", handlePopState);
}, [/* deps */]);
```

**Navigation atoms** (in `settingsState.ts`) automatically push URLs:
- `navigateToDashboardAtom` â†’ `/workspace/{slug}/dashboard`
- `navigateToCollectionAtom` â†’ `/workspace/{slug}/collection/{id}`
- etc.

### 13. "Failed to open scene" When Clicking Scene from Dashboard

> âš ï¸ **Work in Progress**: This fix is functional but needs further testing across all navigation scenarios.

**Problem:** After creating a new scene and returning to the dashboard, clicking on the scene shows "Failed to open scene" error or resets the canvas instead of loading the scene.

**Root Causes:**
1. **Infinite loop**: `handleUrlRoute` called navigation atoms that pushed URLs â†’ triggered `popstate` â†’ called `handleUrlRoute` again â†’ stack overflow
2. **Scene not loading**: `handlePopState` didn't set `appMode` or call scene loading function
3. **Initial URL ignored**: Page load with `/workspace/{slug}/dashboard` showed canvas instead of dashboard

**Current Fix (December 2025):**

1. **`handleUrlRoute` sets state directly** - avoids infinite loops:
```typescript
// WRONG - causes infinite loop:
case "dashboard":
  navigateToDashboard();  // Pushes URL â†’ triggers popstate â†’ loop!

// CORRECT - direct state manipulation:
case "dashboard":
  setAppMode("dashboard");
  setDashboardView("home");
  // No URL push - we're already at the correct URL from popstate
```

2. **`handlePopState` sets canvas mode before loading**:
```typescript
if (route.type === "scene") {
  setAppMode("canvas");  // Switch UI immediately
  if (loadSceneFromUrlRef.current) {
    await loadSceneFromUrlRef.current(workspaceSlug, sceneId);
  }
}
```

3. **Initial URL handling on mount**:
```typescript
const initialRoute = parseUrl();
if (initialRoute.type !== "scene") {
  handleUrlRoute(initialRoute);  // Sets correct mode for dashboard URLs
}
```

**Key Principle - One-Way URL Flow:**
- **User action** â†’ Navigation atom â†’ Push URL â†’ Dispatch popstate
- **Popstate handler** â†’ Parse URL â†’ Set state directly (**NO URL push**)

**Testing Checklist:**
- [ ] Dashboard â†’ Scene â†’ Back
- [ ] Collection â†’ Scene â†’ Back  
- [ ] Private collection navigation
- [ ] Settings pages navigation
- [ ] Direct URL access
- [ ] Browser refresh on each route

**See:** `/docs/URL_ROUTING.md` for full documentation.

### 14. âœ… SOLVED: Scene Data Reset When Switching Scenes

> âœ… **SOLVED** by CSS Hide/Show Pattern - Excalidraw no longer unmounts/remounts.

**Original Problem:** When navigating from dashboard to a scene, the canvas showed empty or stale data.

**Root Cause:** Conditional rendering caused Excalidraw to unmount when switching to dashboard, losing all state.

**Solution:** CSS Hide/Show Pattern (see issue #11 above and `/docs/CRITICAL_CSS_HIDE_SHOW_FIX.md`).

Since Excalidraw is **always mounted**, we simply use `excalidrawAPI.updateScene()` to load new scene data - no need to reset `initialStatePromiseRef` for subsequent loads.

**Current scene loading flow:**
1. User clicks scene in dashboard/sidebar
2. `navigateToSceneAtom` pushes URL
3. `handlePopState` sets `appMode("canvas")` (shows the already-mounted Excalidraw)
4. `loadSceneFromUrl()` fetches data and calls `excalidrawAPI.updateScene()`
5. Scene data appears immediately âœ…

**Race condition handling** is still important for rapid scene switching - track `currentLoadingSceneId` and ignore stale results.

### 15. Deleted Scene URL Stays in Browser History (Back Button Issue)

**Problem:** After deleting a scene and being redirected to dashboard/another scene, clicking the browser Back button tries to navigate to the deleted scene URL.

**Cause:** Using `navigateTo()` (which uses `pushState`) adds a new history entry. The deleted scene URL remains in history.

**Solution:** Use `replaceUrl()` instead of `navigateTo()` when:
1. Deleting a scene and switching to another scene
2. Deleting the last scene and going to dashboard
3. Handling errors when loading a scene (e.g., scene was deleted)

```typescript
// In WorkspaceSidebar.tsx - handleDeleteScene
if (remainingScenes.length > 0) {
  // Replace deleted scene URL with new scene URL
  setCurrentSceneId(remainingScenes[0].id);
  replaceUrl(buildSceneUrl(workspaceSlug, remainingScenes[0].id));
} else {
  // Replace deleted scene URL with dashboard URL
  setAppMode("dashboard");
  replaceUrl(buildDashboardUrl(workspaceSlug));
}

// In App.tsx - loadSceneFromUrl error handler
} catch (error) {
  // Replace invalid scene URL with dashboard URL
  setAppMode("dashboard");
  replaceUrl(buildDashboardUrl(workspaceSlug));
}
```

**Rule:** Use `replaceUrl()` when the current URL should be removed from history (deleted content, errors). Use `navigateTo()` for normal navigation where Back button should work.

## Backend Issues

### 1. Build Fails with "Cannot find module '../auth/jwt-auth.guard'"

**Cause:** Wrong import path.

**Solution:** Use correct path:
```typescript
// CORRECT
import { JwtAuthGuard } from '../auth/jwt.guard';
```

### 2. Build Fails with Express.Multer.File Type Error

**Cause:** Missing `@types/multer` package.

**Solution:** Add to `devDependencies`:
```bash
npm install --save-dev @types/multer
```

### 3. OIDC Discovery Fails in Docker

**Cause:** API container can't resolve external hostname.

**Solution:** Use `OIDC_INTERNAL_URL` in `deploy/.env`:
```bash
OIDC_ISSUER_URL=https://auth.example.com/dex  # External URL
OIDC_INTERNAL_URL=http://dex:5556/dex         # Internal Docker URL
```

### 4. Prisma Migration Issues

**Solution:** For fresh deployments, consolidate migrations:
```bash
# Delete old migrations
rm -rf prisma/migrations/*

# Create new consolidated migration
npx prisma migrate dev --name init
```

## Docker Issues

### 1. Running Docker Commands

**Important:** Docker Compose files are in `deploy/` folder:
```bash
cd deploy
docker compose up -d
docker compose logs -f api
```

### 2. ðŸš¨ CRITICAL: Code Changes Not Being Applied (Docker Build Cache)

**Problem:** You make code changes, rebuild the Docker container, but the changes don't appear in the running application. Checkboxes don't work, new features are missing, etc.

**Cause:** Docker caches build layers. If the `package.json` and other early-stage files haven't changed, Docker reuses cached layers including the `yarn build` step, which means your source code changes are ignored.

**Symptoms:**
- Code changes don't appear after `just up-dev` or `just fresh-dev`
- You see `CACHED` next to build steps in Docker output:
  ```
  #38 [app build 12/12] RUN yarn build:app:docker
  #38 CACHED
  ```
- Event handlers (onClick, onChange) don't fire
- New components or features don't appear

**Solution:** Force rebuild without cache:
```bash
# Rebuild a specific service without cache
just rebuild app

# Or rebuild all without cache
just build-no-cache

# Then restart
just restart
```

**When to use `--no-cache`:**
- After making TypeScript/React code changes that aren't appearing
- When debugging "code should work but doesn't"
- After switching git branches
- When Docker shows `CACHED` for the build step

**Prevention:**
- Always check Docker build output for `CACHED` on the build step
- If you see `CACHED` on the `yarn build` step, your changes weren't included
- Use `just rebuild app` instead of `just up-dev` when actively developing

### 3. Git Detects Subfolders as Embedded Repos

**Cause:** `frontend/`, `backend/`, `room-service/` have their own `.git` folders.

**Solution:** Already in `.gitignore`:
```
frontend/
backend/
room-service/
```

### 2. SSL Certificate Invalid (ERR_CERT_AUTHORITY_INVALID)

**Cause:** Self-signed certificate not trusted.

**Solution:** Accept the certificate in browser, or use Let's Encrypt for production.

### 3. 401 Unauthorized After Login

**Cause:** JWT cookie not being sent.

**Solution:** Ensure `credentials: "include"` in all fetch calls:
```typescript
fetch(url, { credentials: "include" });
```

## Release Process Issues

### 1. Tag Already Exists

**Solution:** Force update the tag:
```bash
git tag -f v0.5.2
git push origin v0.5.2 --force
```

### 2. GitHub Actions Build Fails

**Check:**
1. Run local build first: `npm run build`
2. Check for missing dependencies
3. Verify import paths
4. Ensure all translation keys exist

## Database Issues

### 1. User Not Found After SSO Login

**Cause:** User not being created/linked properly.

**Solution:** Check `UsersService.upsertFromOidc()` logic:
- First checks by OIDC ID
- Then checks by email (migration case)
- Creates new user if neither found

### 2. Scene Data Not Loading

**Check:**
1. Scene exists in PostgreSQL (metadata)
2. Scene data exists in MinIO (actual content)
3. Storage key matches between both

## ðŸ”§ Navigation Debug Tool

### When to Suggest Debug Mode

**Suggest enabling navigation debug mode when the user reports:**
- Scene data not loading or showing wrong content
- Canvas showing empty when opening a scene
- Browser back/forward not working correctly
- Scenes loading twice or not at all
- URL not matching displayed content
- "Failed to open scene" errors
- App freezing or making many API calls (infinite loop suspected)

### How to Enable

Tell the user:

```
This looks like a navigation/scene loading issue. Let's enable debug logging to see what's happening:

1. Add to `deploy/.env`:
   \`\`\`
   DEBUG_NAVIGATION=true
   \`\`\`

2. Restart containers:
   \`\`\`bash
   just restart
   \`\`\`

3. Reproduce the issue in the browser

4. Share the log file:
   \`\`\`bash
   cat deploy/logs/navigation.log
   \`\`\`

The logs will show exactly what navigation events are firing and in what order.
```

### How to Analyze Logs

The log file is NDJSON format (one JSON per line). Key events to look for:

| Issue | Look For |
|-------|----------|
| Scene not loading | `SCENE_LOAD_START` without `SCENE_LOAD_COMPLETE` |
| Wrong scene data | Multiple `SCENE_LOAD_START` for different scenes |
| Infinite loop | Repeating pattern of same events |
| Back button broken | `NAV_URL_PUSH` instead of `NAV_URL_REPLACE` after delete |
| Stale data | `SCENE_LOAD_STALE` appearing unexpectedly |

### Parse Logs with jq

```bash
# Get all scene load events
cat deploy/logs/navigation.log | jq 'select(.event | startswith("SCENE_LOAD"))'

# Get events for a specific scene
cat deploy/logs/navigation.log | jq 'select(.sceneId == "abc123")'

# Count events by type
cat deploy/logs/navigation.log | jq -s 'group_by(.event) | map({event: .[0].event, count: length})'
```

### How to Disable

After debugging:

```bash
# Remove or set to false in deploy/.env
DEBUG_NAVIGATION=false

# Restart
just restart

# Clear old logs (optional)
rm deploy/logs/navigation.log
```

**See:** `/docs/DEBUG_NAVIGATION.md` for complete documentation (enable/disable, log format, all events, jq commands).

