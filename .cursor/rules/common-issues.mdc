---
description: "Common issues and solutions encountered in AstraDraw development"
alwaysApply: true
---

# Common Issues and Solutions

## Frontend Issues

### 1. Translation Key Errors

**Error:** `Argument of type '"some.key"' is not assignable to parameter of type 'NestedKeyOf<{...}>'`

**Solution:** Add the missing key to locale files:
- `frontend/packages/excalidraw/locales/en.json`
- `frontend/packages/excalidraw/locales/ru-RU.json`

### 2. Input Fields Affecting Canvas

**Problem:** Typing in input fields (especially `@`, shortcuts) triggers canvas actions.

**Solution:** Stop event propagation:
```typescript
<input
  onKeyDown={(e) => e.stopPropagation()}
  onKeyUp={(e) => e.stopPropagation()}
/>
```

### 3. Sidebar Overlay vs Push

**Problem:** Sidebar overlays canvas instead of pushing content.

**Solution:** Use flexbox layout:
```scss
.excalidraw-app {
  display: flex;
  .excalidraw-wrapper {
    flex-grow: 1;
  }
}
```

### 4. Auto-save Status Stuck on "Unsaved Changes"

**Problem:** The save status indicator shows "Unsaved changes" (or "–ù–µ—Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è") even after data is successfully saved to the backend.

**Root Cause:** Excalidraw's `onChange` callback fires continuously (~100+ times per second) for every render/state change, not just actual user edits. If you blindly set `hasUnsavedChanges=true` on every `onChange`, it immediately resets the status back to "pending" even after a successful save.

**Solution:** Compare serialized scene data before marking as unsaved:

```typescript
const lastSavedDataRef = useRef<string | null>(null);

// In onChange callback:
if (currentSceneId && !collabAPI?.isCollaborating()) {
  const files = excalidrawAPI?.getFiles() || {};
  const currentData = JSON.stringify({
    type: "excalidraw",
    version: 2,
    source: window.location.href,
    elements,
    appState: {
      viewBackgroundColor: appState.viewBackgroundColor,
      gridSize: appState.gridSize,
    },
    files: files,
  });
  
  // Only set unsaved if data ACTUALLY changed from last save
  if (lastSavedDataRef.current !== currentData) {
    setHasUnsavedChanges(true);
  }
}

// In performSave, after successful save:
lastSavedDataRef.current = dataString;
setHasUnsavedChanges(false);
setSaveStatus("saved");
```

**Additional Fix - Initialize on Scene Load:**

When loading an existing scene, initialize `lastSavedDataRef` with the loaded data to prevent false "unsaved" status:

```typescript
// After loading scene and calling excalidrawAPI.updateScene()
const loadedSceneData = JSON.stringify({
  type: "excalidraw",
  version: 2,
  source: window.location.href,
  elements: sceneWithCollaborators.elements || [],
  appState: {
    viewBackgroundColor: sceneWithCollaborators.appState?.viewBackgroundColor,
    gridSize: sceneWithCollaborators.appState?.gridSize,
  },
  files: sceneWithCollaborators.files || {},
});
lastSavedDataRef.current = loadedSceneData;
setHasUnsavedChanges(false);
setSaveStatus("saved");
```

**Key Insight:** The `onChange` callback is NOT a reliable indicator of user edits - it fires for ANY state change including internal Excalidraw updates. Always compare actual data to detect real changes.

**See:** `/docs/AUTOSAVE.md` for complete implementation details.

### 5. Fonts Look Like Times New Roman in Dashboard/Workspace Components

**Problem:** Text in dashboard, collection views, or scene cards appears in a serif font (Times New Roman) instead of the UI font (Assistant).

**Cause:** Components outside the `.excalidraw` container don't inherit the `--ui-font` CSS variable. The variable is defined in `.excalidraw` class but workspace components (DashboardView, CollectionView, SceneCardGrid, etc.) are rendered outside this container.

**Solution:** Define `--ui-font` locally in each SCSS file for components outside `.excalidraw`:
```scss
.dashboard-view {
  // Define --ui-font locally since component is outside .excalidraw container
  --ui-font: Assistant, system-ui, BlinkMacSystemFont, -apple-system, Segoe UI,
    Roboto, Helvetica, Arial, sans-serif;
  font-family: var(--ui-font);

  // ... rest of styles
}
```

**Files that need this pattern** (if they're outside `.excalidraw`):
- `DashboardView.scss` ‚úÖ
- `CollectionView.scss` ‚úÖ
- `SceneCardGrid.scss` ‚úÖ
- `WorkspaceSidebar.scss` ‚úÖ
- `SceneCard.scss` ‚úÖ
- `LoginDialog.scss` ‚úÖ
- `UserProfileDialog.scss` ‚úÖ
- `ProfilePage.scss` ‚úÖ
- `WorkspaceSettingsPage.scss` ‚úÖ
- `MembersPage.scss` ‚úÖ
- `TeamsCollectionsPage.scss` ‚úÖ
- `EmojiPicker.scss` ‚úÖ
- **Any new workspace/settings/dashboard components**

**IMPORTANT:** When creating a new component in `excalidraw-app/components/` that renders outside the main `.excalidraw` container (e.g., Settings pages, Workspace components, dialogs), ALWAYS add the `--ui-font` definition at the root of its SCSS file.

**Also avoid:** Using `font-family: "Virgil", cursive, var(--ui-font)` which falls back to cursive/serif fonts. Use `var(--ui-font)` directly or inherit from parent.

### 6. Dropdown/Context Menu Not Closing on Outside Click

**Problem:** Context menus or dropdowns don't close when clicking outside them.

**Solution:** Use `useRef` and `useEffect` with a `mousedown` event listener:
```typescript
const menuRef = useRef<HTMLDivElement>(null);
const [menuOpen, setMenuOpen] = useState<string | null>(null);

useEffect(() => {
  const handleClickOutside = (event: MouseEvent) => {
    if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
      setMenuOpen(null);
    }
  };

  if (menuOpen) {
    document.addEventListener("mousedown", handleClickOutside);
  }

  return () => {
    document.removeEventListener("mousedown", handleClickOutside);
  };
}, [menuOpen]);

// In JSX:
<div ref={menuOpen === itemId ? menuRef : null}>
  {/* menu content */}
</div>
```

### 7. Hardcoded Strings Not Translated

**Problem:** Some UI text appears in English even when Russian locale is selected.

**Cause:** Hardcoded strings in components instead of using `t()` function.

**Solution:** 
1. Search for hardcoded strings in the component
2. Add translation keys to both `en.json` and `ru-RU.json`
3. Replace hardcoded strings with `t("key.path")`

**Russian localization tips:**
- Don't translate word-for-word; adapt to natural Russian phrasing
- "by You" ‚Üí "–ê–≤—Ç–æ—Ä: –í—ã" (not "–æ—Ç –í–∞—Å")
- "Just now" ‚Üí "–¢–æ–ª—å–∫–æ —á—Ç–æ"
- Use `{{count}}` for pluralization: "{{count}} –º–∏–Ω. –Ω–∞–∑–∞–¥"

### 8. Data Not Updating Across Components (Cross-Component State Sync)

**Problem:** Data created/updated in one component (e.g., sidebar) doesn't appear in another component (e.g., TeamsCollectionsPage) without a page refresh.

**Cause:** Multiple components have their own local state and fetch data independently. When one component modifies data, others don't know about it.

**Solution:** Use Jotai refresh trigger atoms for cross-component communication:

```typescript
// In settingsState.ts - already defined
export const collectionsRefreshAtom = atom(0);
export const triggerCollectionsRefreshAtom = atom(null, (get, set) => {
  set(collectionsRefreshAtom, get(collectionsRefreshAtom) + 1);
});

// In component that modifies data (e.g., sidebar)
const triggerCollectionsRefresh = useSetAtom(triggerCollectionsRefreshAtom);

const handleCreateCollection = async () => {
  await createCollection(...);
  setLocalCollections(prev => [...prev, newCollection]);
  triggerCollectionsRefresh(); // Notify other components
};

// In component that displays data (e.g., TeamsCollectionsPage)
const collectionsRefresh = useAtomValue(collectionsRefreshAtom);

useEffect(() => {
  loadData();
}, [loadData, collectionsRefresh]); // Re-fetch when refresh is triggered
```

**Available refresh atoms:**
- `collectionsRefreshAtom` / `triggerCollectionsRefreshAtom` - For collection changes
- `scenesRefreshAtom` / `triggerScenesRefreshAtom` - For scene changes

**When to use:**
- After creating, updating, or deleting collections from sidebar
- After creating, renaming, duplicating, or deleting scenes
- When data is modified in one component but displayed in another

### 9. üö® CRITICAL: Infinite Loop in URL Navigation (Stack Overflow)

**Problem:** App crashes with "Maximum call stack size exceeded" when navigating or on page load.

**Cause:** Navigation atoms push URLs via `navigateTo()`, which dispatches `popstate`, which triggers `handlePopState`, which calls a navigation atom again ‚Üí infinite recursion.

**Example of the bug:**
```typescript
// In handlePopState (called on popstate event):
const handlePopState = () => {
  const route = parseUrl();
  if (route.type === "dashboard") {
    navigateToDashboard();  // ‚ùå This pushes URL ‚Üí triggers popstate ‚Üí infinite loop!
  }
};

// navigateToDashboard internally does:
navigateTo(buildDashboardUrl(slug));  // Dispatches popstate event!
```

**Solution - One-Way URL Flow:**
```typescript
// In handlePopState - set state DIRECTLY, don't push URLs:
const handlePopState = () => {
  const route = parseUrl();
  if (route.type === "dashboard") {
    setAppMode("dashboard");    // ‚úÖ Direct state set
    setDashboardView("home");   // ‚úÖ No URL push
  }
};
```

**Rule:** `handlePopState` and `handleUrlRoute` should NEVER call navigation atoms that push URLs. They should only set state atoms directly.

**When to use navigation atoms (that push URLs):**
- User clicks a button/link
- Programmatic navigation from user action

**When to set state directly (no URL push):**
- `handlePopState` (browser back/forward)
- `handleUrlRoute` (processing URL changes)
- Initial URL parsing on page load

### 10. üö® CRITICAL: Infinite Loop in useEffect (API Polling Loop)

**Problem:** The app makes hundreds of API requests per second, causing performance issues and server overload.

**Cause:** A `useEffect` hook has a state variable in its dependency array, but also calls a setter that changes that state (directly or indirectly through callbacks/parent components).

**Common patterns that cause infinite loops:**

#### Pattern 1: Direct state dependency loop
```typescript
// ‚ùå BAD: activeCollectionId in deps, but setActiveCollectionId called inside
useEffect(() => {
  loadData().then((data) => {
    if (!activeCollectionId) {
      setActiveCollectionId(data.defaultId); // Changes activeCollectionId ‚Üí re-runs effect
    }
  });
}, [activeCollectionId, setActiveCollectionId]); // ‚Üê activeCollectionId causes loop
```

```typescript
// ‚úÖ GOOD: Use a ref to track if default was already set
const hasSetDefaultRef = useRef(false);

useEffect(() => {
  loadData().then((data) => {
    if (!hasSetDefaultRef.current) {
      hasSetDefaultRef.current = true;
      setActiveCollectionId(data.defaultId);
    }
  });
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, [setActiveCollectionId]); // Removed activeCollectionId from deps
```

#### Pattern 2: Callback chain loop (Parent ‚Üî Child)
```typescript
// ‚ùå BAD: Child notifies parent on every collections change
// WorkspaceSidebar.tsx
useEffect(() => {
  if (currentWorkspace) {
    onWorkspaceChange(currentWorkspace, privateCollection?.id);
  }
}, [currentWorkspace, collections, onWorkspaceChange]); // ‚Üê collections causes loop

// App.tsx - Parent reloads collections when notified
onWorkspaceChange={(workspace) => {
  listCollections(workspace.id).then(setCollections); // Updates collections ‚Üí triggers child effect
}}
```

```typescript
// ‚úÖ GOOD: Only notify parent once per workspace change
const lastNotifiedWorkspaceRef = useRef<string | null>(null);

useEffect(() => {
  if (currentWorkspace && lastNotifiedWorkspaceRef.current !== currentWorkspace.id) {
    lastNotifiedWorkspaceRef.current = currentWorkspace.id;
    onWorkspaceChange(currentWorkspace, privateCollection?.id);
  }
}, [currentWorkspace, collections, onWorkspaceChange]);
```

#### Pattern 3: Redundant data fetching
```typescript
// ‚ùå BAD: Both parent and child fetch the same data
// Child already loads collections, but parent also reloads them
onWorkspaceChange={(workspace) => {
  listCollections(workspace.id).then(setCollections); // Redundant!
}}
```

```typescript
// ‚úÖ GOOD: Let one component own the data loading
onWorkspaceChange={(workspace, privateColId) => {
  setCurrentWorkspace(workspace);
  setPrivateCollectionId(privateColId);
  // Don't reload collections - child already loaded them
}}
```

**Debugging infinite loops:**
1. Open browser DevTools ‚Üí Network tab
2. Look for repeated requests to the same endpoint
3. Check the call stack to find which component/effect is triggering
4. Search for `useEffect` hooks that both depend on and modify the same state

**Prevention checklist for new useEffect hooks:**
- [ ] Does this effect call any state setters?
- [ ] Are any of those state variables also in the dependency array?
- [ ] Does this effect call any callbacks that might update state in parent/sibling components?
- [ ] Could those state updates cause this effect to re-run?
- [ ] If yes to any: Use a ref to prevent duplicate executions

**IMPORTANT:** When you see an effect that sets state, ALWAYS check if that state (or derived state) is in the dependency array. If it is, you likely have an infinite loop.

### 11. Scene Data Loss When Navigating Between Dashboard and Canvas

> ‚úÖ **SOLVED** - See `/docs/CRITICAL_CSS_HIDE_SHOW_FIX.md` for the complete solution.

**Problem:** Scene data was lost or reset when navigating between dashboard and canvas views.

**Root Cause:** The original code used conditional rendering (`if (appMode === "dashboard") return <Dashboard />`) which caused Excalidraw to unmount/remount when switching modes, losing all state.

**Solution: CSS Hide/Show Pattern**

Instead of conditional rendering, both Dashboard and Canvas are **always mounted** and CSS `display: none` toggles visibility:

```typescript
// ‚úÖ CORRECT - CSS Hide/Show (current implementation)
return (
  <>
    <div style={{ display: appMode === "dashboard" ? "block" : "none" }}>
      <WorkspaceMainContent />
    </div>
    <div 
      style={{ display: appMode === "canvas" ? "block" : "none" }}
      inert={appMode !== "canvas" ? true : undefined}
    >
      <Excalidraw />
    </div>
  </>
);
```

**Key safeguards:**
- `display: none` - Hides visually
- `inert` attribute - Prevents all user interaction when hidden
- `handleKeyboardGlobally={appMode === "canvas"}` - Disables keyboard when hidden
- `body.excalidraw-disabled` class - Additional CSS hook

**See:** `/docs/CRITICAL_CSS_HIDE_SHOW_FIX.md` for complete documentation.

### 12. Browser Back/Forward Buttons Not Working

**Problem:** Clicking browser back/forward doesn't navigate correctly in the app.

**Cause:** Navigation only changes React state, not browser history.

**Solution:** All navigation atoms now push URLs and the app listens for `popstate` events:

```typescript
// In App.tsx
useEffect(() => {
  const handlePopState = async (event: PopStateEvent) => {
    const route = parseUrl();
    // Update state based on route type
  };
  
  window.addEventListener("popstate", handlePopState);
  return () => window.removeEventListener("popstate", handlePopState);
}, [/* deps */]);
```

**Navigation atoms** (in `settingsState.ts`) automatically push URLs:
- `navigateToDashboardAtom` ‚Üí `/workspace/{slug}/dashboard`
- `navigateToCollectionAtom` ‚Üí `/workspace/{slug}/collection/{id}`
- etc.

### 13. "Failed to open scene" When Clicking Scene from Dashboard

> ‚ö†Ô∏è **Work in Progress**: This fix is functional but needs further testing across all navigation scenarios.

**Problem:** After creating a new scene and returning to the dashboard, clicking on the scene shows "Failed to open scene" error or resets the canvas instead of loading the scene.

**Root Causes:**
1. **Infinite loop**: `handleUrlRoute` called navigation atoms that pushed URLs ‚Üí triggered `popstate` ‚Üí called `handleUrlRoute` again ‚Üí stack overflow
2. **Scene not loading**: `handlePopState` didn't set `appMode` or call scene loading function
3. **Initial URL ignored**: Page load with `/workspace/{slug}/dashboard` showed canvas instead of dashboard

**Current Fix (December 2025):**

1. **`handleUrlRoute` sets state directly** - avoids infinite loops:
```typescript
// WRONG - causes infinite loop:
case "dashboard":
  navigateToDashboard();  // Pushes URL ‚Üí triggers popstate ‚Üí loop!

// CORRECT - direct state manipulation:
case "dashboard":
  setAppMode("dashboard");
  setDashboardView("home");
  // No URL push - we're already at the correct URL from popstate
```

2. **`handlePopState` sets canvas mode before loading**:
```typescript
if (route.type === "scene") {
  setAppMode("canvas");  // Switch UI immediately
  if (loadSceneFromUrlRef.current) {
    await loadSceneFromUrlRef.current(workspaceSlug, sceneId);
  }
}
```

3. **Initial URL handling on mount**:
```typescript
const initialRoute = parseUrl();
if (initialRoute.type !== "scene") {
  handleUrlRoute(initialRoute);  // Sets correct mode for dashboard URLs
}
```

**Key Principle - One-Way URL Flow:**
- **User action** ‚Üí Navigation atom ‚Üí Push URL ‚Üí Dispatch popstate
- **Popstate handler** ‚Üí Parse URL ‚Üí Set state directly (**NO URL push**)

**Testing Checklist:**
- [ ] Dashboard ‚Üí Scene ‚Üí Back
- [ ] Collection ‚Üí Scene ‚Üí Back  
- [ ] Private collection navigation
- [ ] Settings pages navigation
- [ ] Direct URL access
- [ ] Browser refresh on each route

**See:** `/docs/URL_ROUTING.md` for full documentation.

### 14. ‚úÖ SOLVED: Scene Data Reset When Switching Scenes

> ‚úÖ **SOLVED** by CSS Hide/Show Pattern - Excalidraw no longer unmounts/remounts.

**Original Problem:** When navigating from dashboard to a scene, the canvas showed empty or stale data.

**Root Cause:** Conditional rendering caused Excalidraw to unmount when switching to dashboard, losing all state.

**Solution:** CSS Hide/Show Pattern (see issue #11 above and `/docs/CRITICAL_CSS_HIDE_SHOW_FIX.md`).

Since Excalidraw is **always mounted**, we simply use `excalidrawAPI.updateScene()` to load new scene data - no need to reset `initialStatePromiseRef` for subsequent loads.

**Current scene loading flow:**
1. User clicks scene in dashboard/sidebar
2. `navigateToSceneAtom` pushes URL
3. `handlePopState` sets `appMode("canvas")` (shows the already-mounted Excalidraw)
4. `loadSceneFromUrl()` fetches data and calls `excalidrawAPI.updateScene()`
5. Scene data appears immediately ‚úÖ

**Race condition handling** is still important for rapid scene switching - track `currentLoadingSceneId` and ignore stale results.

### 15. Deleted Scene URL Stays in Browser History (Back Button Issue)

**Problem:** After deleting a scene and being redirected to dashboard/another scene, clicking the browser Back button tries to navigate to the deleted scene URL.

**Cause:** Using `navigateTo()` (which uses `pushState`) adds a new history entry. The deleted scene URL remains in history.

**Solution:** Use `replaceUrl()` instead of `navigateTo()` when:
1. Deleting a scene and switching to another scene
2. Deleting the last scene and going to dashboard
3. Handling errors when loading a scene (e.g., scene was deleted)

```typescript
// In WorkspaceSidebar.tsx - handleDeleteScene
if (remainingScenes.length > 0) {
  // Replace deleted scene URL with new scene URL
  setCurrentSceneId(remainingScenes[0].id);
  replaceUrl(buildSceneUrl(workspaceSlug, remainingScenes[0].id));
} else {
  // Replace deleted scene URL with dashboard URL
  setAppMode("dashboard");
  replaceUrl(buildDashboardUrl(workspaceSlug));
}

// In App.tsx - loadSceneFromUrl error handler
} catch (error) {
  // Replace invalid scene URL with dashboard URL
  setAppMode("dashboard");
  replaceUrl(buildDashboardUrl(workspaceSlug));
}
```

**Rule:** Use `replaceUrl()` when the current URL should be removed from history (deleted content, errors). Use `navigateTo()` for normal navigation where Back button should work.

## Backend Issues

### 1. Build Fails with "Cannot find module '../auth/jwt-auth.guard'"

**Cause:** Wrong import path.

**Solution:** Use correct path:
```typescript
// CORRECT
import { JwtAuthGuard } from '../auth/jwt.guard';
```

### 2. Build Fails with Express.Multer.File Type Error

**Cause:** Missing `@types/multer` package.

**Solution:** Add to `devDependencies`:
```bash
npm install --save-dev @types/multer
```

### 3. OIDC Discovery Fails in Docker

**Cause:** API container can't resolve external hostname.

**Solution:** Use `OIDC_INTERNAL_URL` in `deploy/.env`:
```bash
OIDC_ISSUER_URL=https://auth.example.com/dex  # External URL
OIDC_INTERNAL_URL=http://dex:5556/dex         # Internal Docker URL
```

### 4. Prisma Migration Issues

**Solution:** For fresh deployments, consolidate migrations:
```bash
# Delete old migrations
rm -rf prisma/migrations/*

# Create new consolidated migration
npx prisma migrate dev --name init
```

## Docker Issues

### 1. Running Docker Commands

**Important:** Docker Compose files are in `deploy/` folder:
```bash
cd deploy
docker compose up -d
docker compose logs -f api
```

### 2. üö® CRITICAL: Code Changes Not Being Applied (Docker Build Cache)

**Problem:** You make code changes, rebuild the Docker container, but the changes don't appear in the running application. Checkboxes don't work, new features are missing, etc.

**Cause:** Docker caches build layers. If the `package.json` and other early-stage files haven't changed, Docker reuses cached layers including the `yarn build` step, which means your source code changes are ignored.

**Symptoms:**
- Code changes don't appear after `just up-dev` or `just fresh-dev`
- You see `CACHED` next to build steps in Docker output:
  ```
  #38 [app build 12/12] RUN yarn build:app:docker
  #38 CACHED
  ```
- Event handlers (onClick, onChange) don't fire
- New components or features don't appear

**Solution:** Force rebuild without cache:
```bash
# Rebuild a specific service without cache
just rebuild app

# Or rebuild all without cache
just build-no-cache

# Then restart
just restart
```

**When to use `--no-cache`:**
- After making TypeScript/React code changes that aren't appearing
- When debugging "code should work but doesn't"
- After switching git branches
- When Docker shows `CACHED` for the build step

**Prevention:**
- Always check Docker build output for `CACHED` on the build step
- If you see `CACHED` on the `yarn build` step, your changes weren't included
- Use `just rebuild app` instead of `just up-dev` when actively developing

### 3. Git Detects Subfolders as Embedded Repos

**Cause:** `frontend/`, `backend/`, `room-service/` have their own `.git` folders.

**Solution:** Already in `.gitignore`:
```
frontend/
backend/
room-service/
```

### 2. SSL Certificate Invalid (ERR_CERT_AUTHORITY_INVALID)

**Cause:** Self-signed certificate not trusted.

**Solution:** Accept the certificate in browser, or use Let's Encrypt for production.

### 3. 401 Unauthorized After Login

**Cause:** JWT cookie not being sent.

**Solution:** Ensure `credentials: "include"` in all fetch calls:
```typescript
fetch(url, { credentials: "include" });
```

## Release Process Issues

### 1. Tag Already Exists

**Solution:** Force update the tag:
```bash
git tag -f v0.5.2
git push origin v0.5.2 --force
```

### 2. GitHub Actions Build Fails

**Check:**
1. Run local build first: `npm run build`
2. Check for missing dependencies
3. Verify import paths
4. Ensure all translation keys exist

## Database Issues

### 1. User Not Found After SSO Login

**Cause:** User not being created/linked properly.

**Solution:** Check `UsersService.upsertFromOidc()` logic:
- First checks by OIDC ID
- Then checks by email (migration case)
- Creates new user if neither found

### 2. Scene Data Not Loading

**Check:**
1. Scene exists in PostgreSQL (metadata)
2. Scene data exists in MinIO (actual content)
3. Storage key matches between both

## üîß Navigation Debug Tool

### When to Suggest Debug Mode

**Suggest enabling navigation debug mode when the user reports:**
- Scene data not loading or showing wrong content
- Canvas showing empty when opening a scene
- Browser back/forward not working correctly
- Scenes loading twice or not at all
- URL not matching displayed content
- "Failed to open scene" errors
- App freezing or making many API calls (infinite loop suspected)

### How to Enable

Tell the user:

```
This looks like a navigation/scene loading issue. Let's enable debug logging to see what's happening:

1. Add to `deploy/.env`:
   \`\`\`
   DEBUG_NAVIGATION=true
   \`\`\`

2. Restart containers:
   \`\`\`bash
   just restart
   \`\`\`

3. Reproduce the issue in the browser

4. Share the log file:
   \`\`\`bash
   cat deploy/logs/navigation.log
   \`\`\`

The logs will show exactly what navigation events are firing and in what order.
```

### How to Analyze Logs

The log file is NDJSON format (one JSON per line). Key events to look for:

| Issue | Look For |
|-------|----------|
| Scene not loading | `SCENE_LOAD_START` without `SCENE_LOAD_COMPLETE` |
| Wrong scene data | Multiple `SCENE_LOAD_START` for different scenes |
| Infinite loop | Repeating pattern of same events |
| Back button broken | `NAV_URL_PUSH` instead of `NAV_URL_REPLACE` after delete |
| Stale data | `SCENE_LOAD_STALE` appearing unexpectedly |

### Parse Logs with jq

```bash
# Get all scene load events
cat deploy/logs/navigation.log | jq 'select(.event | startswith("SCENE_LOAD"))'

# Get events for a specific scene
cat deploy/logs/navigation.log | jq 'select(.sceneId == "abc123")'

# Count events by type
cat deploy/logs/navigation.log | jq -s 'group_by(.event) | map({event: .[0].event, count: length})'
```

### How to Disable

After debugging:

```bash
# Remove or set to false in deploy/.env
DEBUG_NAVIGATION=false

# Restart
just restart

# Clear old logs (optional)
rm deploy/logs/navigation.log
```

**See:** `/docs/DEBUG_NAVIGATION.md` for complete documentation (enable/disable, log format, all events, jq commands).

## Auto-Collaboration for Shared Collections

### Overview

Scenes in non-private collections of SHARED workspaces automatically have collaboration enabled. Users see each other's cursors immediately without clicking "Share".

### Key Implementation Details

1. **Room credentials stored in database**: `roomId` and `roomKeyEncrypted` on Scene model
2. **AES-128-GCM key format**: 22-character base64url string (16 bytes encoded)
3. **`isAutoCollab` flag**: Prevents scene reset when joining collaboration

### Common Issues

#### Encryption Key Length Error

**Error:** `DataError: The JWK "k" member did not include the right length of key data`

**Cause:** Room key is not 22 characters (base64url encoding of 16 bytes for AES-128-GCM).

**Solution:** Generate key with `randomBytes(16).toString('base64url')`:
```typescript
private generateRoomKey(): string {
  return randomBytes(16).toString('base64url'); // Returns 22 chars
}
```

#### Scene Data Lost on First Load

**Problem:** Opening a shared scene shows blank canvas.

**Cause:** `startCollaboration()` calls `resetScene()` before loading from room storage.

**Solution:** Pass `isAutoCollab: true` to keep current scene data:
```typescript
await collabAPI.startCollaboration({
  roomId: loaded.roomId,
  roomKey: loaded.roomKey,
  isAutoCollab: true, // Don't reset scene
});
```

#### Autosave Shows "Unsaved" During Collaboration

**Problem:** SaveStatusIndicator shows "Unsaved changes" during collaboration.

**Cause:** Autosave is disabled during collaboration, but indicator still shows.

**Solution:** Hide SaveStatusIndicator when collaborating:
```typescript
const showSaveStatus = isAuthenticated && currentSceneId && !isLegacyMode && !isCollaborating;
```

### State Management

Use `isAutoCollabSceneAtom` to track auto-collab state:
```typescript
// In settingsState.ts
export const isAutoCollabSceneAtom = atom<boolean>(false);

// Set when loading scene
setIsAutoCollabScene(loaded.access.canCollaborate && !!loaded.roomId);
```

**See:** `/docs/AUTO_COLLABORATION.md` for complete documentation.

## Thumbnail Preview System

### Overview

Scene thumbnails are generated client-side after each successful save and uploaded to MinIO/S3.

**See:** `/docs/THUMBNAIL_PREVIEW.md` for complete documentation.

### Common Issues

#### MinIO URLs Not Resolving (ERR_NAME_NOT_RESOLVED)

**Problem:** Browser shows `net::ERR_NAME_NOT_RESOLVED` for URLs like `minio:9000/bucket/...`

**Cause:** The browser can't resolve internal Docker hostnames. MinIO's internal hostname (`minio`) is only accessible within the Docker network.

**Solution:** Use one of these approaches:

1. **Development (Traefik proxy):** Expose MinIO via Traefik at `/s3/` path
   ```yaml
   # docker-compose.yml - minio service
   labels:
     - "traefik.enable=true"
     - "traefik.http.routers.minio-s3.rule=Host(`${APP_DOMAIN}`) && PathPrefix(`/s3`)"
     - "traefik.http.services.minio-s3.loadbalancer.server.port=9000"
     - "traefik.http.middlewares.minio-s3-stripprefix.stripprefix.prefixes=/s3"
     - "traefik.http.routers.minio-s3.middlewares=minio-s3-stripprefix"
   ```
   Then generate URLs like `/s3/bucket/thumbnails/id.png`

2. **Production (public S3 URL):** Set `S3_PUBLIC_URL` environment variable
   ```bash
   S3_PUBLIC_URL=https://s3.example.com  # No trailing slash!
   ```
   Then generate URLs like `https://s3.example.com/bucket/thumbnails/id.png`

**URL generation pattern:**
```typescript
const s3PublicUrl = process.env.S3_PUBLIC_URL;
const bucket = (process.env.S3_BUCKET || 'excalidraw').replace(/^\//, '');

if (s3PublicUrl) {
  // Production: direct S3/CDN URL
  thumbnailUrl = `${s3PublicUrl.replace(/\/+$/, '')}/${bucket}/thumbnails/${key}`;
} else {
  // Development: Traefik proxy
  thumbnailUrl = `/s3/${bucket}/thumbnails/${key}`;
}
```

#### URL Malformed with Double Slashes

**Problem:** URLs contain `//` like `https://s3.example.com//bucket/...`

**Cause:** Environment variables have trailing or leading slashes.

**Solution:** Always sanitize:
```typescript
// Strip trailing slashes from base URL
const baseUrl = s3PublicUrl.replace(/\/+$/, '');

// Strip leading slashes from bucket name
const bucket = (process.env.S3_BUCKET || 'excalidraw').replace(/^\//, '');

// Build URL
const url = `${baseUrl}/${bucket}/path`;
```

### 16. CSS Hide/Show Pattern Broken by `display: flex !important`

**Problem:** Dashboard and canvas show side-by-side instead of one being hidden.

**Cause:** SCSS rule like `display: flex !important` overrides the inline `display: none` style used by the CSS Hide/Show pattern.

**Example of the bug:**
```scss
// ‚ùå BAD: This breaks inline display: none
.excalidraw-app__dashboard {
  display: flex !important;  // Always shows, even when should be hidden
}
```

**Solution:** Use `aria-hidden` attribute as the single source of truth:

```scss
// ‚úÖ GOOD: aria-hidden controls visibility
.excalidraw-app__dashboard {
  flex-direction: column;
  overflow: hidden;

  &[aria-hidden="true"] {
    display: none !important;
  }

  &[aria-hidden="false"] {
    display: flex;
  }
}
```

```tsx
// In JSX - set aria-hidden based on mode
<div
  className="excalidraw-app__dashboard"
  aria-hidden={appMode !== "dashboard"}
>
  <WorkspaceMainContent />
</div>
```

**Key principle:** When using CSS Hide/Show pattern, never use `display: X !important` unconditionally. Either:
1. Use `aria-hidden` attribute to control display
2. Or use inline styles only (no SCSS `!important`)

**See:** `/docs/CRITICAL_CSS_HIDE_SHOW_FIX.md` for the full pattern.

### 17. Dark Mode Not Working for Workspace Components

**Problem:** Sidebar, dashboard, or settings pages don't switch to dark mode when the canvas does.

**Cause:** Dark mode styles only use `.excalidraw.theme--dark` selector, but workspace components are **outside** the `.excalidraw` container.

**DOM Structure:**
```
.excalidraw-app.theme--dark        ‚Üê Theme class must be HERE
‚îú‚îÄ‚îÄ .workspace-sidebar             ‚Üê Outside .excalidraw!
‚îú‚îÄ‚îÄ .excalidraw-app__dashboard     ‚Üê Outside .excalidraw!
‚îî‚îÄ‚îÄ .excalidraw-app__canvas
    ‚îî‚îÄ‚îÄ .excalidraw.theme--dark    ‚Üê Theme class also here
```

**Solution:** Always use **both** selectors for dark mode:

```scss
// ‚ùå BAD - only works for components inside .excalidraw
.excalidraw.theme--dark {
  .my-component { ... }
}

// ‚úÖ GOOD - works for all workspace components
.excalidraw.theme--dark,
.excalidraw-app.theme--dark {
  .my-component { ... }
}
```

**Files that need both selectors:**
- All files in `excalidraw-app/components/Workspace/`
- All files in `excalidraw-app/components/Settings/`
- `EmojiPicker.scss`, `SaveStatusIndicator.scss`

**See:** `/docs/WORKSPACE_UI_STYLING.md` for complete dark mode patterns.

### 18. Text Not Readable in Dark Mode

**Problem:** Text appears dark gray on dark background, making it unreadable.

**Cause:** Missing explicit color overrides in dark mode section.

**Common elements that need dark mode color overrides:**
- Form labels (`label`)
- Input text and placeholders
- Dialog titles (`h2`)
- Field values
- Member names/emails
- Hints and descriptions

**Solution:** Add explicit color overrides:

```scss
.excalidraw-app.theme--dark {
  .my-component {
    // Primary text (headings, names, values)
    &__title,
    &__name,
    &__field-value {
      color: var(--text-primary-color, #e1e1e1);
    }

    // Secondary text (hints, descriptions, placeholders)
    &__subtitle,
    &__hint {
      color: var(--text-secondary-color, #9b9b9b);
    }

    // Inputs and selects
    &__input {
      background: var(--island-bg-color, #232329);
      color: var(--text-primary-color, #e1e1e1);

      &::placeholder {
        color: var(--text-secondary-color, #9b9b9b);
      }
    }

    // Dialog headers
    &__dialog-header h2 {
      color: var(--text-primary-color, #e1e1e1);
    }

    // Form labels
    &__form-group label {
      color: var(--text-primary-color, #e1e1e1);
    }
  }
}
```

**Dark mode color reference:**
| Element | Light | Dark |
|---------|-------|------|
| Primary text | `#1b1b1f` | `#e1e1e1` |
| Secondary text | `#6b6b6b` | `#9b9b9b` |
| Page background | `#fafafa` | `#1e1e24` |
| Card background | `#ffffff` | `#232329` |
| Borders | `#e5e5e5` | `#3d3d3d` |

**See:** `/docs/WORKSPACE_UI_STYLING.md` for complete styling guide.

