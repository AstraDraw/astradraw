---
description: "State management patterns for AstraDraw frontend (React Query + Jotai)"
globs: ["frontend/excalidraw-app/components/Settings/settingsState.ts", "frontend/excalidraw-app/App.tsx", "frontend/excalidraw-app/hooks/*.ts", "frontend/excalidraw-app/lib/*.ts"]
---

# Frontend State Management

**Key files for context:**
@frontend/excalidraw-app/lib/queryClient.ts
@frontend/excalidraw-app/components/Settings/settingsState.ts
@frontend/excalidraw-app/hooks/

## State Categories

1. **Server State (React Query)** - Data from API (scenes, workspaces, collections)
2. **Client State (Jotai)** - UI state shared across components (navigation, selection)
3. **Local State (useState)** - Component-specific UI state

## React Query vs Jotai vs useState

**Use React Query when:**
1. Fetching data from the API (scenes, workspaces, collections, profiles)
2. You need caching and request deduplication
3. You need automatic background refetching

**Use Jotai Atom when:**
1. Multiple components need the same client state (avoid prop drilling)
2. State needs to be set by action atoms (navigation)
3. State is part of URL/routing
4. State needs localStorage persistence

**Use useState when:**
1. State is truly component-local (form inputs)
2. State is temporary/transient (hover, animation)
3. Only one component reads/writes this state

## Jotai Usage Patterns

```typescript
// Import from app-jotai (NOT directly from jotai)
import { useAtom, useAtomValue, useSetAtom } from "../../app-jotai";

// Read-only
const value = useAtomValue(myAtom);

// Read and write
const [value, setValue] = useAtom(myAtom);

// Write-only (for actions)
const setValue = useSetAtom(myAtom);
```

## Creating New Atoms

**Location:** `excalidraw-app/components/Settings/settingsState.ts`

```typescript
// Simple state atom
export const myStateAtom = atom<string>("");

// With localStorage persistence
const STORAGE_KEY = "my_preference";
export const myPreferenceAtom = atom<boolean>(
  typeof window !== "undefined"
    ? localStorage.getItem(STORAGE_KEY) === "true"
    : false
);

// Action atom (write-only)
export const myActionAtom = atom(null, (get, set, params: MyParams) => {
  set(myStateAtom, newValue);
});

// Derived atom
export const derivedAtom = atom((get) => get(atomA) + get(atomB));
```

## React Query Usage

```typescript
// Query client and keys
import { useQueryClient } from "@tanstack/react-query";
import { queryKeys } from "../lib/queryClient";

// Fetching data - use hooks
import { useScenesCache } from "../hooks/useScenesCache";
const { scenes, isLoading, updateScenes } = useScenesCache({
  workspaceId,
  collectionId,
  enabled: !!workspaceId,
});

// After mutations - invalidate queries
const queryClient = useQueryClient();
await deleteScene(sceneId);
queryClient.invalidateQueries({ queryKey: queryKeys.scenes.all });
```

## Existing Atoms Reference (Jotai - Client State)

| Category | Atoms |
|----------|-------|
| **Navigation** | `appModeAtom`, `dashboardViewAtom`, `activeCollectionIdAtom` |
| **Navigation Actions** | `navigateToDashboardAtom`, `navigateToCollectionAtom`, `navigateToSceneAtom` |
| **Workspace Selection** | `workspacesAtom`, `currentWorkspaceAtom`, `currentWorkspaceSlugAtom` |
| **Collections Selection** | `collectionsAtom`, `privateCollectionAtom` (derived), `activeCollectionAtom` (derived) |
| **Scene** | `currentSceneIdAtom`, `currentSceneTitleAtom`, `isAutoCollabSceneAtom` |
| **Sidebar** | `workspaceSidebarOpenAtom`, `toggleWorkspaceSidebarAtom` |
| **Refresh Triggers** | `collectionsRefreshAtom`, `triggerCollectionsRefreshAtom` |

> **Note:** `scenesCacheAtom` and `scenesRefreshAtom` have been removed. Use React Query instead.

## Cross-Component Communication

For collections (still uses Jotai trigger):
```typescript
const triggerRefresh = useSetAtom(triggerCollectionsRefreshAtom);
await createCollection(...);
triggerRefresh();
```

For scenes (use React Query):
```typescript
const queryClient = useQueryClient();
await deleteScene(sceneId);
queryClient.invalidateQueries({ queryKey: queryKeys.scenes.all });
```

## Navigation Pattern

**Key principle - One-Way URL Flow:**
- **User action** → Navigation atom → Push URL → Dispatch popstate
- **Popstate handler** → Parse URL → Set state directly (**NO URL push**)

```typescript
// User clicks scene
const navigateToScene = useSetAtom(navigateToSceneAtom);
navigateToScene({ workspaceSlug, sceneId, title });

// In useUrlRouting hook - set state DIRECTLY (no URL push)
// This is now extracted to hooks/useUrlRouting.ts
```

**Rule:** `handlePopState` (in `useUrlRouting`) should NEVER call navigation atoms that push URLs.

## App.tsx Hooks

App.tsx uses extracted hooks for better maintainability:

| Hook | Purpose |
|------|---------|
| `useAutoSave` | Save state machine, debounce, retry, offline |
| `useSceneLoader` | Scene loading, auto-collab join |
| `useUrlRouting` | Popstate, URL parsing |
| `useKeyboardShortcuts` | Ctrl+S, Cmd+P, Cmd+[, Cmd+] |

## Data Management Hooks

These hooks use React Query for fetching + Jotai for selection state:

| Hook | Data Source | Purpose |
|------|-------------|---------|
| `useScenesCache` | React Query | Fetch scenes with caching |
| `useWorkspaces` | React Query + Jotai | Load workspaces, manage selection |
| `useCollections` | React Query + Jotai | Load collections, manage selection |
| `useSceneActions` | React Query invalidation | Delete/rename/duplicate scenes |
| `useInvalidateScenesCache` | React Query | Invalidate scenes cache |

**When to create a new hook:**
- Logic is 50+ lines and has single responsibility
- Logic could be reused in another component
- Logic has its own state + effects that form a cohesive unit

## Migration: useState to Jotai

**Signs you should migrate:**
1. Same prop passed through 3+ levels
2. Multiple unrelated components need same state
3. Action atom needs to set this state
4. State needs localStorage persistence

```typescript
// BEFORE: useState with prop drilling
const [sidebarOpen, setSidebarOpen] = useState(false);
<Child isOpen={sidebarOpen} onClose={() => setSidebarOpen(false)} />

// AFTER: Jotai atom
// In settingsState.ts
export const sidebarOpenAtom = atom<boolean>(false);

// Any component can read/write directly
const isOpen = useAtomValue(sidebarOpenAtom);
const close = useSetAtom(closeSidebarAtom);
```

**See:** `/docs/architecture/STATE_MANAGEMENT.md` for complete documentation.
